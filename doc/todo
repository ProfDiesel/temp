Socket: tester writev (LD_PRELOAD)

Trigger: normalized_move_trigger
Trigger: polymorphic_trigger_dispatcher, use boost-ext/te

Config: Pre-hashed strings
Config: faire une unité de compil séparée avec le parser

Logger: n'autoriser que les types triviaux (sauf explicite) -> fonction unique de fmt / push dans logger
Logger: pour les types complexes, push d'observer_ptr gérés en QSBR

Tests: UB + Address Sanitizer
Tests: Crux (crux.galois.com)
Tests: Mull: mull.readthedocs.io

Model: polymorphic_trigger: pointeur sur fonction uniquement pour le trigger, méthodes virtuelles pour reset et warm_up

Feed: decoder PCAP, decoder Wireshark

S'assurer qu'avec Onload, on ne passe jamais dans le scheduler du système
Restaurer les const

Genjutsu: variant dynamiques: déterminées par une liste de flags (similaire aux dependencies)

feed_server.hpp: finir play()
backtest_harness.hpp: buffer_feeder::on_snapshot_request, ajouter une state_map



https://github.com/compudj/librseq
https://easyperf.net/blog/2019/02/09/Top-Down-performance-analysis-methodology
https://easyperf.net/blog/2019/04/03/Precise-timing-of-machine-code-with-Linux-perf
https://github.com/andikleen/pmu-tools
https://github.com/dry-python

https://github.com/Refinitiv/Real-Time-SDK
